# js 正则表达式
    匹配模式，匹配字符 or 位置

## 字符匹配
- 模糊匹配
    1. 横向模糊匹配
        匹配的字符串长度不固定，使用量词  {m, n} 连续出现最少m次最多n次
        g  全局匹配，按顺序匹配所有子串  /要匹配的字符串/g
    2. 纵向模糊匹配
        [abc]  匹配a或者b或者c，匹配到任何其中一个就行

- 字符组
    1. 范围表示法
        [abc]  字符组，匹配其中一个字符
        `-`  省略简写较长有规律的字符串  [123456789] 可以写成 [1-9]
        如果要匹配带有-的字符串，可以更改内部顺序不为[1-9]就行
    2. 排除字符组
        也叫反义字符组，[^abc]  匹配除a，b，c之外的任意字符
    3. 常见的简写形式
        \d  [0-9]  数字
        \D  [^0-9]  除数字外任意字符
        \w  [0-9a-zA-Z_]  单词字符，数字、大小写字母、下划线
        \W  [^0-9a-zA-Z_]
        \s  [ \t\v\n\r\f]  空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符
        \S  [^ \t\v\n\r\f]
        . 即是[^\n\r\u2028\u2029]  通配符，除了换行符、回车符、行分隔符和段分隔符的任意字符

- 量词
    也称重复
    1. 简写形式
        {m}  出现m次
        {m,}  出现最少m次
        ?  等价于{0, 1}  出现或者不出现
        +  等价于{1,}  出现最少一次
        *  等价于{0,}  出现任意次，可能不出现
    2. 贪婪匹配
        /\d{2, 5}/g  匹配数字连续出现2到5次，即会匹配连续的2、3、4、5位数字形式出现的
        在能力范围内，匹配越多越好
        不是一件好事
    3. 惰性匹配
        尽可能少的匹配
        /\d{2, 5}?/g  虽然匹配的是连续出现2到5次的，到只匹配连续出现两次的就够了，不再往下匹配出现更多次的
        通过在量词后面加 ? 实现惰性匹配

- 多选分支
    对比模糊匹配，它可以支持多个子模式任选其一  
    p1|p2|p3|p4|p5|p6|  p是子模式，用管道符 | 分隔
    但它也有惰性，比如，即匹配到了前面的，后面的便不继续了
```
    var regex = /goodbye|good/g;  // 匹配到了goodbye
    var regex = /good|goodbye/g;  // 匹配到了good
    var string = "goodbye";
    console.log( string.match(regex) ); 
```

## 位置匹配
    相邻字符之间的位置
- 六个锚字符，匹配位置
    1. ^ 和 $
        ^ 匹配开头，多行匹配中匹配每行开头
        $ 匹配结尾，多行匹配中匹配每行结尾
    2. \b 和 \B
        \b是单词边界，具体就是\w和\W之间的位置，也包括\w和^之间的位置，也包
        括\w和$之间的位置
        \B 与 \b 相反，非单词边界
    3. (?=p) 和 (?!p)
        (?=p)，其中p是一个子模式，即p前面的位置，比如(?=l)，表示'l'字符前面的位置
        (?!p) 就是 (?=p) 的反面意思

- 位置特性
    字符之间的位置，可以写成多个
    位置类比空字符

## 括号的作用

- 分组和分支  
    /(ab)+/    (p1|p2)
- 引用分组  
    可以进行提取数据以及替换
    str.match(regex)  返回一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本
    如果正则是否有修饰符g，match返回的数组格式是不一样的
    regex.exec(str)  与match类似
    也可以使用构造函数的全局属性$1至$9来获取  RegExp.$1  即提取第一组数据
- 反向引用
    可以在正则本身里引用分组，但只能引用之前出现的分组
    `如：var regex = /\d{4}(-|\/|\.)\d{2}\1\d{2}/;`
    `\1，表示的引用之前的那个分组(-|\/|\.)`
    括号嵌套  按遍历嵌套层，每层从左到右进行分组
    \10 表示第10个分组，而不是\1和0
    引用不存在的分组则匹配其匹配字符本身
    如果只想要括号最原始的功能，可以使用非捕获分组(?:p)

## 回溯法原理
    深度优先搜索算法，退到之前的某一步这一过程，我们称为“回溯”
    尝试匹配失败时，接下来的一步通常就是回溯
- 没有回溯的匹配
    设一个正则是/ab{1,3}c/
    当目标字符串是"abbbc"时，就没有所谓的“回溯”
- 有回溯的匹配
    目标字符串是"abbc"，中间就有回溯
    因为目标字符串只有两个b，匹配进行时，已经匹配了两个b，接下来匹配第三个，但发现是c，所以回溯到之前的状态，再匹配c
- 常见的回溯形式
    1. 贪婪量词
        尝试可能的顺序是从多往少的方向去尝试，然后再看整个正则是否能匹配
        当多个贪婪量词挨着存在，并相互有冲突时，先下手为强
    2. 惰性量词
        为了整体匹配成功，会有回溯
    3. 分支结构
        表达式整体不匹配时，仍会继续尝试剩下的分支。
        这种尝试也可以看成一种回溯
    相对那些DFA引擎，有回溯的过程，那么匹配效率肯定低一些
    JS的正则引擎是NFA，NFA是“非确定型有限自动机”的简写，匹配慢，但编译快

## 正则表达式拆分

- 结构和操作符
    字面量，匹配一个具体字符
    字符组，匹配一个字符，多种可能之一  [0-9]  \d
    量词，表示一个字符连续出现
    锚点，匹配一个位置
    分组，用括号表示一个整体
    分支，多个子表达式多选一
    反向引用  \2
    涉及的操作符有：优先级从上到下，由高到低
        1.转义符 \
        2.括号和方括号 (...)、(?:...)、(?=...)、(?!...)、[...]
        3.量词限定符 {m}、{m,n}、{m,}、?、*、+
        4.位置和序列 ^ 、$、 \元字符、 一般字符
        5. 管道符（竖杠）|
    元字符，有特殊含义的字符：匹配它们本身时需要转义  
        ^ $ . * + ? | \ / ( ) [ ] { } = ! : - ,

        ^ [] - 字符组里面的，在引起歧义的地方进行转义
        例，匹配字符串"[abc]"，写成/\[abc]/进行对 [ 的转义就可以
        括号需要在前后都转义 \( \)
        = ! : - ,等符号，只要不在特殊结构中，不需要转义

## 正则表达式的构建

- 平衡法则
    1. 匹配预期的字符串
    2. 不匹配非预期的字符串
    3. 可读性和可维护性
    4. 效率
- 构建正则前提
    1. 是否能使用正则
    2. 是否有必要使用正则
        能用字符串api解决的简单问题就用api
    3. 是否有必要构建一个复杂的正则
        可以分化成多个小正则
- 准确性
    能匹配预期的目标，并且不匹配非预期的目标
    1. 了解各部分的模式规则
    2. 明确形式关系  要匹配的东西是什么新式，或还是什么关系，可不可以构建分支，提取公告部分，简写
    3. 平衡取舍
- 效率
    正则表达式的运行分为如下的阶段：
        1. 编译
        2. 设定起始位置
        3. 尝试匹配
        4. 匹配失败的话，从下一位开始继续第3步
        5. 最终结果：匹配成功或失败
    优化：
        1. 使用具体型字符组来代替通配符，来消除回溯
        2. 使用非捕获型分组
        3. 独立出确定字符
        4. 提取分支公共部分
        5. 减少分支的数量，缩小它们的范围

## 正则表达式编程

- 四种操作
    验证、切分、提取、替换
    匹配的本质是查找
    1. 验证
        判断是否的操作
        最直接的应用   表单验证
        相关api：search  test(较常用)  match  exec  
    2. 切分
        把目标字符串，切成一段一段的
        相关api：split
    3. 提取
        正则通常要使用分组引用（分组捕获）功能
        配合使用相关API：exec  test  search  replace  match(较常用)
    4. 替换
        相关api：replace
- 注意点：
    1. search 和 match，会把字符串转换为正则的
        str.search(".") 需要写成 str.search("/\./")
    2. match 返回结果的格式，与正则对象是否有修饰符 g 有关
        无g：["2017", "2017", index: 0, input: "2017.06.27"]  标准格式
        有g：["2017", "06", "27"]  所有匹配内容
    3. 当正则没有g时，使用match返回的信息比较多。但是有g后，就没有关键的信息index了。而exec方法就能解决这个问题，它能接着上一次匹配后继续匹配
    4. lastIndex 属性，表示下一次匹配开始的位置
    5. 在使用exec时，经常需要配合使用while循环
    6. 字符串的四个方法，每次匹配时，都是从0开始的，即lastIndex属性始终不变。正则实例的两个方法exec、test，当正则是全局匹配时，每一次匹配完成后，都会修改lastIndex。如果没有g，自然都是从字符串第0个字符处开始尝试匹配
    7. test整体匹配时需要使用^和$
    ```
        console.log( /123/.test("a123b") );
        // => true
        console.log( /^123$/.test("a123b") );
        // => false
        console.log( /^123$/.test("123") );
        // => true
    ```
    8. split可以有第二个参数，表示结果数组的最大长度.正则使用分组时，结果数组中是包含分隔符的
    9. replace有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数
    ```
        $1,$2,...,$99 匹配第1~99个分组里捕获的文本
        $& 匹配到的子串文本
        $` 匹配到的子串的左边文本
        $' 匹配到的子串的右边文本
        ? 美元符号
    ```
    10. 不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多 \

- 修饰符
    1. g 全局匹配，即找到所有匹配的，单词是global
    2. i 忽略字母大小写，单词ingoreCase
    3. m 多行匹配，只影响^和$，二者变成行的概念，即行开头和行结尾。单词是
    multiline
    4. source属性，在构建动态的正则表达式时，可以通过查看该属性，来确认构建出的正则到底是什么
    5. 构造函数属性：不常用，有兼容性问题
        - RegExp.input 最近一次目标字符串，简写成RegExp["$_"]
        - RegExp.lastMatch 最近一次匹配的文本，简写成RegExp["$&"]
        - RegExp.lastParen 最近一次捕获的文本，简写成RegExp["$+"]
        - RegExp.leftContext 目标字符串中lastMatch之前的文本，简写成RegExp["$`"]
        - RegExp.rightContext 目标字符串中lastMatch之后的文本，简写成RegExp["$'"]

