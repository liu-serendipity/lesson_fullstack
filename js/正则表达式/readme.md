# js 正则表达式
    匹配模式，匹配字符 or 位置

## 字符匹配
- 模糊匹配
    1. 横向模糊匹配
        匹配的字符串长度不固定，使用量词  {m, n} 连续出现最少m次最多n次
        g  全局匹配，按顺序匹配所有子串  /要匹配的字符串/g
    2. 纵向模糊匹配
        [abc]  匹配a或者b或者c，匹配到任何其中一个就行

- 字符组
    1. 范围表示法
        [abc]  字符组，匹配其中一个字符
        `-`  省略简写较长有规律的字符串  [123456789] 可以写成 [1-9]
        如果要匹配带有-的字符串，可以更改内部顺序不为[1-9]就行
    2. 排除字符组
        也叫反义字符组，[^abc]  匹配除a，b，c之外的任意字符
    3. 常见的简写形式
        \d  [0-9]  数字
        \D  [^0-9]  除数字外任意字符
        \w  [0-9a-zA-Z_]  单词字符，数字、大小写字母、下划线
        \W  [^0-9a-zA-Z_]
        \s  [ \t\v\n\r\f]  空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符
        \S  [^ \t\v\n\r\f]
        . 即是[^\n\r\u2028\u2029]  通配符，除了换行符、回车符、行分隔符和段分隔符的任意字符

- 量词
    也称重复
    1. 简写形式
        {m}  出现m次
        {m,}  出现最少m次
        ?  等价于{0, 1}  出现或者不出现
        +  等价于{1,}  出现最少一次
        *  等价于{0,}  出现任意次，可能不出现
    2. 贪婪匹配
        /\d{2, 5}/g  匹配数字连续出现2到5次，即会匹配连续的2、3、4、5位数字形式出现的
        在能力范围内，匹配越多越好
        不是一件好事
    3. 惰性匹配
        尽可能少的匹配
        /\d{2, 5}?/g  虽然匹配的是连续出现2到5次的，到只匹配连续出现两次的就够了，不再往下匹配出现更多次的
        通过在量词后面加 ? 实现惰性匹配

- 多选分支
    对比模糊匹配，它可以支持多个子模式任选其一  
    p1|p2|p3|p4|p5|p6|  p是子模式，用管道符 | 分隔
    但它也有惰性，比如，即匹配到了前面的，后面的便不继续了
```
    var regex = /goodbye|good/g;  // 匹配到了goodbye
    var regex = /good|goodbye/g;  // 匹配到了good
    var string = "goodbye";
    console.log( string.match(regex) ); 
```

## 位置匹配
    相邻字符之间的位置
- 六个锚字符，匹配位置
    1. ^ 和 $
        ^ 匹配开头，多行匹配中匹配每行开头
        $ 匹配结尾，多行匹配中匹配每行结尾
    2. \b 和 \B
        \b是单词边界，具体就是\w和\W之间的位置，也包括\w和^之间的位置，也包
        括\w和$之间的位置
        \B 与 \b 相反，非单词边界
    3. (?=p) 和 (?!p)
        (?=p)，其中p是一个子模式，即p前面的位置，比如(?=l)，表示'l'字符前面的位置
        (?!p) 就是 (?=p) 的反面意思

- 位置特性
    字符之间的位置，可以写成多个
    位置类比空字符

## 括号的作用

- 分组和分支  
    /(ab)+/    (p1|p2)
- 引用分组  
    可以进行提取数据以及替换
    str.match(regex)  返回一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本
    如果正则是否有修饰符g，match返回的数组格式是不一样的
    regex.exec(str)  与match类似
    也可以使用构造函数的全局属性$1至$9来获取  RegExp.$1  即提取第一组数据
- 反向引用
    可以在正则本身里引用分组，但只能引用之前出现的分组
    `如：var regex = /\d{4}(-|\/|\.)\d{2}\1\d{2}/;`
    `\1，表示的引用之前的那个分组(-|\/|\.)`
    括号嵌套  按遍历嵌套层，每层从左到右进行分组
    \10 表示第10个分组，而不是\1和0
    引用不存在的分组则匹配其匹配字符本身
    如果只想要括号最原始的功能，可以使用非捕获分组(?:p)

## 回溯法原理
    深度优先搜索算法，退到之前的某一步这一过程，我们称为“回溯”
    尝试匹配失败时，接下来的一步通常就是回溯
- 没有回溯的匹配
    设一个正则是/ab{1,3}c/
    当目标字符串是"abbbc"时，就没有所谓的“回溯”
- 有回溯的匹配
    目标字符串是"abbc"，中间就有回溯
    因为目标字符串只有两个b，匹配进行时，已经匹配了两个b，接下来匹配第三个，但发现是c，所以回溯到之前的状态，再匹配c
- 常见的回溯形式
    1. 贪婪量词
        尝试可能的顺序是从多往少的方向去尝试，然后再看整个正则是否能匹配
        当多个贪婪量词挨着存在，并相互有冲突时，先下手为强
    2. 惰性量词
        为了整体匹配成功，会有回溯
    3. 分支结构
        表达式整体不匹配时，仍会继续尝试剩下的分支。
        这种尝试也可以看成一种回溯
    相对那些DFA引擎，有回溯的过程，那么匹配效率肯定低一些
    JS的正则引擎是NFA，NFA是“非确定型有限自动机”的简写，匹配慢，但编译快

